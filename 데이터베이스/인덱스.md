# 인덱스

### 인덱스의 필요성
*** 
인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치입니다. 예를 들어 책의 마지막 장에 있는 찾아보기를 생각하면 됩니다. 인덱스를 설정하면 테이블 안에 내가 찾고자 하는 데이터를 빠르게 찾을 수 있습니다.

### B-트리
***
인덱스는 보통 B-트리라는 자료 구조로 이루어져 있습니다. 이는 루트 노드, 리프 노드, 브랜치 노드(루트 노드와 리프 노드 사이)로 나뉩니다. 트리 탐색은 맨 위 루트 노드부터 탐색이 일어나며 브랜치 노드를 거쳐 리프 노드까지 내려옵니다.

### 인덱스가 효율적인 이유와 대수확장성
***
인덱스가 효율적인 이유는 효율적인 단계를 거쳐서 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 대수확장성 때문입니다.

대수확장성이란 트리 깊이가 리프 노트 수에 비해 매우 느리게 성장하는 것을 의미합니다. 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가합니다. 트리 10개 짜리로 100만 개의 레코드를 검색할 수 있습니다.

### 인덱스를 만드는 방법
***
인덱스를 만드는 방법은 데이터베이스마다 방법이 다릅니다.

### MySQL
***
 클러스터형 인덱스와 세컨더리 인덱스가 있습니다. 클러스터형 인덱스는 데이블당 하나를 설정할 수 있습니다. primary key 옵션으로 기본키를 만들면 클러스터형 인덱스를 생성할 수 있고, 기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스를 만들 수 있습니다. create index... 명령어를 기반으로 만들면 세컨더리 인덱스를 만들 수 있습니다. 하나의 인덱스만 생성할 것이라면 클러스터형 인덱스르 만드는 것이 세컨더리 인덱스를 만드는 것보다 성능이 좋습니다. 세컨더리 인덱스는 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스입니다. 다양한 필드를 기반으로 쿼리를 보낼 때는 세컨더리 인덱스를 사용해야 합니다.

 ### MongoDB
 ***
 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본기로 설정됩니다. 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있습니다.

 ### 인덱스 최적화 기법
 ***
 인덱스 최적화 기법은 데이터베이스마다 조금씩 다르지만 기본적인 골조는 똑같기 때문에 크게 다르지 않습니다.

 1. 인덱스는 비용이다 : 먼저 인덱스는 두 번 탐색하도록 강요합니다. 인덱스 리스트, 컬렉션 순으로 탐색을 합니다.
 컬렉션이 수정되었을 때 인덱스도 수정되야 합니다. B-트리의 높이를 균형 있게 조절하는 비용도 들고, 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 발생합니다. 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 답이 아닙니다. 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적입니다.

 2. 항상 테스팅하라 : explain()함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화 해야 합니다.

 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순입니다. : 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성하는데, 인덱스를 생성할 때 순서가 있고 생성 순서에 따라 인덱의 성능이 달라집니다. 